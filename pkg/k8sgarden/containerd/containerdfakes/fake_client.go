// Code generated by counterfeiter. DO NOT EDIT.
package containerdfakes

import (
	"context"
	"sync"

	"code.cloudfoundry.org/k8s-garden-client/pkg/k8sgarden/containerd"
	"github.com/containerd/containerd/v2/client"
	v1 "k8s.io/api/core/v1"
)

type FakeClient struct {
	DeleteStub        func(context.Context, client.Image) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 context.Context
		arg2 client.Image
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	IsServingStub        func(context.Context) (bool, error)
	isServingMutex       sync.RWMutex
	isServingArgsForCall []struct {
		arg1 context.Context
	}
	isServingReturns struct {
		result1 bool
		result2 error
	}
	isServingReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	LoadTasksStub        func(context.Context, []v1.ContainerStatus) (map[string]client.Task, error)
	loadTasksMutex       sync.RWMutex
	loadTasksArgsForCall []struct {
		arg1 context.Context
		arg2 []v1.ContainerStatus
	}
	loadTasksReturns struct {
		result1 map[string]client.Task
		result2 error
	}
	loadTasksReturnsOnCall map[int]struct {
		result1 map[string]client.Task
		result2 error
	}
	PullStub        func(context.Context, string, string, string) (client.Image, int64, error)
	pullMutex       sync.RWMutex
	pullArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	pullReturns struct {
		result1 client.Image
		result2 int64
		result3 error
	}
	pullReturnsOnCall map[int]struct {
		result1 client.Image
		result2 int64
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) Delete(arg1 context.Context, arg2 client.Image) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 context.Context
		arg2 client.Image
	}{arg1, arg2})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1, arg2})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeClient) DeleteCalls(stub func(context.Context, client.Image) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeClient) DeleteArgsForCall(i int) (context.Context, client.Image) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) IsServing(arg1 context.Context) (bool, error) {
	fake.isServingMutex.Lock()
	ret, specificReturn := fake.isServingReturnsOnCall[len(fake.isServingArgsForCall)]
	fake.isServingArgsForCall = append(fake.isServingArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.IsServingStub
	fakeReturns := fake.isServingReturns
	fake.recordInvocation("IsServing", []interface{}{arg1})
	fake.isServingMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) IsServingCallCount() int {
	fake.isServingMutex.RLock()
	defer fake.isServingMutex.RUnlock()
	return len(fake.isServingArgsForCall)
}

func (fake *FakeClient) IsServingCalls(stub func(context.Context) (bool, error)) {
	fake.isServingMutex.Lock()
	defer fake.isServingMutex.Unlock()
	fake.IsServingStub = stub
}

func (fake *FakeClient) IsServingArgsForCall(i int) context.Context {
	fake.isServingMutex.RLock()
	defer fake.isServingMutex.RUnlock()
	argsForCall := fake.isServingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) IsServingReturns(result1 bool, result2 error) {
	fake.isServingMutex.Lock()
	defer fake.isServingMutex.Unlock()
	fake.IsServingStub = nil
	fake.isServingReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) IsServingReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isServingMutex.Lock()
	defer fake.isServingMutex.Unlock()
	fake.IsServingStub = nil
	if fake.isServingReturnsOnCall == nil {
		fake.isServingReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isServingReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) LoadTasks(arg1 context.Context, arg2 []v1.ContainerStatus) (map[string]client.Task, error) {
	var arg2Copy []v1.ContainerStatus
	if arg2 != nil {
		arg2Copy = make([]v1.ContainerStatus, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.loadTasksMutex.Lock()
	ret, specificReturn := fake.loadTasksReturnsOnCall[len(fake.loadTasksArgsForCall)]
	fake.loadTasksArgsForCall = append(fake.loadTasksArgsForCall, struct {
		arg1 context.Context
		arg2 []v1.ContainerStatus
	}{arg1, arg2Copy})
	stub := fake.LoadTasksStub
	fakeReturns := fake.loadTasksReturns
	fake.recordInvocation("LoadTasks", []interface{}{arg1, arg2Copy})
	fake.loadTasksMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) LoadTasksCallCount() int {
	fake.loadTasksMutex.RLock()
	defer fake.loadTasksMutex.RUnlock()
	return len(fake.loadTasksArgsForCall)
}

func (fake *FakeClient) LoadTasksCalls(stub func(context.Context, []v1.ContainerStatus) (map[string]client.Task, error)) {
	fake.loadTasksMutex.Lock()
	defer fake.loadTasksMutex.Unlock()
	fake.LoadTasksStub = stub
}

func (fake *FakeClient) LoadTasksArgsForCall(i int) (context.Context, []v1.ContainerStatus) {
	fake.loadTasksMutex.RLock()
	defer fake.loadTasksMutex.RUnlock()
	argsForCall := fake.loadTasksArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) LoadTasksReturns(result1 map[string]client.Task, result2 error) {
	fake.loadTasksMutex.Lock()
	defer fake.loadTasksMutex.Unlock()
	fake.LoadTasksStub = nil
	fake.loadTasksReturns = struct {
		result1 map[string]client.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) LoadTasksReturnsOnCall(i int, result1 map[string]client.Task, result2 error) {
	fake.loadTasksMutex.Lock()
	defer fake.loadTasksMutex.Unlock()
	fake.LoadTasksStub = nil
	if fake.loadTasksReturnsOnCall == nil {
		fake.loadTasksReturnsOnCall = make(map[int]struct {
			result1 map[string]client.Task
			result2 error
		})
	}
	fake.loadTasksReturnsOnCall[i] = struct {
		result1 map[string]client.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Pull(arg1 context.Context, arg2 string, arg3 string, arg4 string) (client.Image, int64, error) {
	fake.pullMutex.Lock()
	ret, specificReturn := fake.pullReturnsOnCall[len(fake.pullArgsForCall)]
	fake.pullArgsForCall = append(fake.pullArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.PullStub
	fakeReturns := fake.pullReturns
	fake.recordInvocation("Pull", []interface{}{arg1, arg2, arg3, arg4})
	fake.pullMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) PullCallCount() int {
	fake.pullMutex.RLock()
	defer fake.pullMutex.RUnlock()
	return len(fake.pullArgsForCall)
}

func (fake *FakeClient) PullCalls(stub func(context.Context, string, string, string) (client.Image, int64, error)) {
	fake.pullMutex.Lock()
	defer fake.pullMutex.Unlock()
	fake.PullStub = stub
}

func (fake *FakeClient) PullArgsForCall(i int) (context.Context, string, string, string) {
	fake.pullMutex.RLock()
	defer fake.pullMutex.RUnlock()
	argsForCall := fake.pullArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) PullReturns(result1 client.Image, result2 int64, result3 error) {
	fake.pullMutex.Lock()
	defer fake.pullMutex.Unlock()
	fake.PullStub = nil
	fake.pullReturns = struct {
		result1 client.Image
		result2 int64
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) PullReturnsOnCall(i int, result1 client.Image, result2 int64, result3 error) {
	fake.pullMutex.Lock()
	defer fake.pullMutex.Unlock()
	fake.PullStub = nil
	if fake.pullReturnsOnCall == nil {
		fake.pullReturnsOnCall = make(map[int]struct {
			result1 client.Image
			result2 int64
			result3 error
		})
	}
	fake.pullReturnsOnCall[i] = struct {
		result1 client.Image
		result2 int64
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ containerd.Client = new(FakeClient)
